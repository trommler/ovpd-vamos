Einleitung

Eine Bank will das ihre Kunden Ihre Accounts einsehen und die Transaction für die einzelnen Accounts in einer Webanwendung abfragen können.
Dafür nutzt sie eine gängige Three-Tier-Architecture mit einem Browser, einen Application-Server und einem Datenbankserver. Wichtig zu erwähnen ist, das bei dieser Architecture es meinstens für die Abfrage des vom Datenbankservers vom Applicationserver nur einen Big Application User gibt, und die User der Anwendung nicht in der Datenbank explizit angelegt sind. 

IMG 3TArchitecture

Wir gehen davon aus das es bei dieser Anwendung die Entitäten "Bank Customer", "Bank Account" und "Transaction" gibt ( Siehe Bild unten).
Der Customer wird mit der Customer Number, der Account über seine IBAN und die Transaction über eine ID eindeutig identifiziert.

Das Bild below zeigt das ERD-Diagramm zu unserem Case.
IMG CASE BANK

Ruft der Customer mit der ID "1" die Bankwebseite auf, loggt sich ein, dann werden Ihm alle seine Konten angezeigt.
Klickt er nun auf ein Konto drauf, generiert die Webseite eine HTTP-Request für den Applicationserver, um alle zugehörigen Transactionen für diesen Account anzuzeigen.
Wird dieser nun abgefangen und die Parameter der SQL-Query so manipuliert das nicht die Transactions für die Konten von Customer mit der ID "1" abgefragt werden, sondern die von Customer mit der ID "2", könnte die Datenbank überlistet werden und der Customer sieht nun Transactionen für die er kein Zugriff hat. 
Dieser Brocken-Access-Controll (OWASP Top 5 Szenario 1), funktioniert nur, wenn die Datenbank nicht bei jedem Request nach dem Login überprüft wer diesen Request stellt. 

Um dies zu verhindern wollen wir in der Datenbank die Querys als Secound line of defense nochmalig überprüfen.
Als Lösung schlagen Roichman and Gudes Parameterized Views vor [Quelle (Fine-grained Access Control to Web Databases)], was wir mit der Virtual Private Database (VPD) von Oracle im nächsten Abschnitt versuchen umzusetzen.

PV und VPD

Die Virtual Private Database (VPD) von Oracle ist eine in der Oracle DB enterprise 12c integriert Sicherheitsfunktionalität die ankommende SQL Querys auf ein bestimmtes Objekt (zb. Tabelle oder View) mit vorher definierten Parametern erweitert, um den Zugriff einzuschränken.
Die Idee der Parameterized Views (PV)(Roichman und Gudes) werden wir nun mit der VPD umsetzen.
 
Eine wichtige Vorraussetzung für PV ist, das der Datenbank (DB) die Authentifiaction des aktuellen Nutzers mitgeteilt wird, er wird mit application ssession key (AS-key) umgesetzt, für die höhere Sicherheit noch mit dem rolling key verfahren ergänzt (Roichman und Gudes). 

Um Daten und User zu speichern, gibt es in der Oracle DB unterschiedliche Arten von Contexten.
Local Application Context (LAC), Global Application Context (GAC) und Client-Session Based Applicatin Context (CSBAC). Wir haben uns für den GAC entschieden, da dieser Context für unsere 3-Tier-Architecture mit Connectionspools am besten geeignet ist. Auf die anderne Contexte gehen wir aus Relevanzgründen nicht näher ein.

Quelle ( Das umfassende Handbuch 12c 11.3.1 Applications Context)

Der GAC ist ein Name => Value Store und speichert für jede Application in einem globalen Variablen Speicher die benötigten Daten, um einen Sessionless access zu ermöglichen. Da wird die SessionId, des Security Token und die UserID vom Applicationserver für jeden einzelnen Anwendungsuser gespeichert, und für die Datenbankabfrage bereitgestellt.

Details entnehmen Sie bitte dem Oracle Security Guide 12c (July 2017, Section 9-2, Page 318).

Wir gehen in diesem Paper davon aus, das es diese Unique ID (bsp. eine Matrikelnummer, Kundennummer, UserID, SessionID, Token) in angemessener Sicherheit bereits vorliegt und von der Datenbank überprüft werden kann. Auf die Erzeugung bzw. den Angriff auf diese ID wird hier nicht näher betrachtet, da (Roichman und Gudes) dies schon getan haben.

In PV spielt die Parameter Methode die größte Rolle da sie die eigentliche Einschränkung mit Query rewriting erwirkt. Oracle nennt dies die VPD-Policy-Function. In dieser werden die Input Parameter( schema, object) festgelegt und der Return wert ( must be from Typ VARCHAR2) bestimmt. 

Um nun ein Object like a table,view oder synonym mit dieser Policy-function zu schützen, d.h. eine PV zu erzeugen, wird die Policy-function mit hilfe der DBMS_RLS.ADD_POLICY procedure über eine VPD-Policy einem Object like a table,view oder synonyms zugewiesen werden. Dies garantiert das die Policy-function can not be bypass from the query and a valide predicate must be append on every Query. The Parameters Tampering attack wich was described in Broken Access control (BAC)(OWASP top 5,sezenario 1) and (Roichman und Gudes), can now detected and the attacker can´t see other data outside the PV with Datarecords which contains releated Information to his AS-key/ID. Das führt zu einer Row-Level-Security, da nur Rows des aktuell authorisierten Users angezeigt werden.


Kategorien 
Der Big Application User (BAU) hat einen entscheidenden Nachteil. Aufgrund seiner oben beschriebenen Funktionalität kann er evtentuell vorhandene Kategorien der einzelen User nicht unterscheiden, bzw. Berücksichtigen.
Den Begriff Kategorie grenzen wir in dieser Arbeit deutlich von Rollen in einer DBMS als Rechteverwaltungsentität ab. Die Kategorie kann nur von der Anwendung selber erkannt werden, und in dem GAC mit eingetragen werden. Die VPD kann dies dann bei dem Query Rewriting als Predicate mit einbinden.



Policy function for case bank (SQL):



Example Thesis

Haben wir nun ein Szenario, in dem eine Tabelle mehrere Fremdschlüsselbeziehungen aus unterschiedlichen Tabellen hat, muss die Policy function wie folgt angepasst werden.

angepasste Policy function for case thesis(SQL):


Example Language

angepasste Policy function for case Langugage(SQL):



Natürlich ist es noch immer möglich SQL-Injection Attacken zu fahren, diese werden hier aber nicht nähere betrachtet, da Sie relativ einfach verhindert (z.b. durch Prepared Statements, leichter erkennbar sind als BAC´s und auf Daten anderer keine Auswirkung mehr haben, weil die PV nur noch die Daten der anfragenenden ID zurückgibt.


Policy Typen der VPD
!!!our choice is context sensitive!!!!!

This policy type does not optimize database performance as the static and context sensitive policy types do. However, Oracle recommends that before you set policies as either static or context-sensitive, you should first test them as DYNAMIC policy types, which run every time. Testing policy functions as DYNAMIC policies first enables you to observe how the policy function affects each query, because nothing is cached. 

****hint to enforce Statement types****
Bei der prodecure DBMS_RLS.ADD_POLICY ist es wichtig das man die statement_types (SELECT, INSERT, UPDATE, INDEX, and DELETE) explizit angibt, für die diese Policy gelten soll, lässt man die Werte auf Default, dann gilt  die Policy nicht für INDEX, was wieder rum eine Sicherheitslücke darstellen kann. 
***************************************

Quelle (Securityguide 12c 2017)


Verallgemeinerung der Cases für die Zuordnung zur Policy (compiler):

CASE 1
Befindet sich in einer Tabelle "A" der PK "pa" welcher in der Tabelle "B" der FK "fb" ist und gibt es einen PK "pb" in der Tabelle "B" 
der FK "fc" in der Tabelle "C" ist, so benötigt man in der VPD eine function mit den folgenden Variablen:

CASE 1 simple:
Befindet sich in einer Tabelle "A" der PK "pa" welcher in der Tabelle "B" der FK "fb" ist, so benötigt man in der VPD eine function mit den folgenden Variablen:

/*SQL for CASE 1 simple*/
CREATE OR REPLACE FUNCTION case_1_simple_policy (obj_schema varchar2, obj_name varchar2) RETURN varchar2
 is                
 BEGIN
   select IBAN, OWNER, ACCOUNT_TYPE
   from B
   INNER JOIN A ON B.fb = A.pa
   where pa = SYS_CONTEXT('A.pa', 'id');
   return 'IBAN = '|| v_iban;
   
 END;


/*SQL for CASE 1*/
/*create context*/
CREATE CONTEXT global_bank_ctx USING bank_ctx_pkg ACCESSED GLOBALLY;
/*create package*/
CREATE OR REPLACE PACKAGE bank_ctx_pkg AS
	PROCEDURE set_bank_ctx(owner IN VARCHAR2);
	PROCEDURE set_session_id(session_id_p IN NUMBER);
	PROCEDURE clear_bank_session(session_id_p IN NUMBER);
	PROCEDURE clear_bank_ctx;
END;
/
/*create body*/
CREATE OR REPLACE PACKAGE BODY bank_ctx_pkg
	AS
    session_id_global NUMBER;
    PROCEDURE set_session_id(session_id_p IN NUMBER) AS
	BEGIN
		session_id_global := session_id_p;
        DBMS_SESSION.SET_IDENTIFIER(session_id_p);
	END set_session_id;
	PROCEDURE set_bank_ctx(owner IN VARCHAR2) AS
	BEGIN
		DBMS_SESSION.SET_CONTEXT( 
			namespace 	=> 'global_bank_ctx',
			attribute 	=>'bank_acc',
			value 		=> owner,
			username 	=> USER, -- Session user,
			client_id 	=> session_id_global
			);
	END set_bank_ctx;
	PROCEDURE clear_bank_session(session_id_p IN NUMBER) AS
	BEGIN 
		DBMS_SESSION.SET_IDENTIFIER(session_id_p);
		DBMS_SESSION.CLEAR_IDENTIFIER;
	END clear_bank_session;
	PROCEDURE clear_bank_ctx AS
	BEGIN
		DBMS_SESSION.CLEAR_CONTEXT('global_bank_ctx', 'bank_acc');
	END clear_bank_ctx;
	
END;
/

/*grant rights*/
GRANT EXECUTE ON bank_ctx_pkg TO appbank;

/*check compiling*/
show errors;



/*test that as appbank*/
BEGIN 
    system.bank_ctx_pkg.set_session_id(34256);
END;

/*Set the session ID:*/
EXEC system.bank_ctx_pkg.set_session_id(34256);

/*Check the session ID:*/
SELECT SYS_CONTEXT('userenv', 'client_identifier') FROM DUAL;

/*set context manuell*/
EXEC system.bank_ctx_pkg.set_bank_ctx('1234');

/*check the context*/
SELECT SYS_CONTEXT('global_bank_ctx', 'bank_acc') owner FROM DUAL;

/*clear session*/
EXEC system.bank_ctx_pkg.clear_bank_session(34256);

/*check the context*/
SELECT SYS_CONTEXT('global_bank_ctx', 'bank_acc') owner FROM DUAL;

/*clear context values*/
EXEC system.bank_ctx_pkg.clear_bank_ctx;

/*check the context*/
SELECT SYS_CONTEXT('global_bank_ctx', 'bank_acc') owner FROM DUAL;


/*Drop Policy*/
EXEC DBMS_RLS.DROP_POLICY('appbank','BANK_ACCOUNT','case1simple');










/*KOMPILIERT UNTER APPBANK*/
CREATE OR REPLACE FUNCTION case_1_simple_policy (obj_schema varchar2, obj_name varchar2) RETURN varchar2
 IS
 v_iban number(34);
 v_owner varchar2(20);
 v_account_type varchar2(20);  
 BEGIN
   select IBAN, OWNER, ACCOUNT_TYPE
   into v_iban, v_owner, v_account_type
   from BANK_ACCOUNT
   INNER JOIN BANK_CUSTOMERS ON BANK_ACCOUNT.OWNER = BANK_CUSTOMERS.CUST_NO
   where OWNER = SYS_CONTEXT('USERENV', 'SESSION_USER');
   return 'IBAN = '|| v_iban; 
 END;
 /
/*KOMPILIERT UNTER APPBANK*/


/*KOMPILIERT UNTER APPBANK*/
CREATE OR REPLACE FUNCTION case_1_simple_policy (obj_schema varchar2, obj_name varchar2) RETURN varchar2
 IS
v_iban number(34);
v_owner varchar2(20);
v_account_type varchar2(20);            
 BEGIN
   SELECT "A1"."IBAN_0" "IBAN","A1"."OWNER_1" "OWNER","A1"."ACCOUNT_TYPE_2" "ACCOUNT_TYPE"
   INTO v_iban, v_owner, v_account_type
   FROM  (SELECT "A3"."IBAN" "IBAN_0","A3"."OWNER" "OWNER_1","A3"."ACCOUNT_TYPE" "ACCOUNT_TYPE_2","A2"."CUST_NO" "CUST_NO" 
   FROM "APPBANK"."BANK_ACCOUNT" "A3","APPBANK"."BANK_CUSTOMERS" "A2" WHERE "A3"."OWNER"="A2"."CUST_NO") "A1" 
   WHERE "A1"."OWNER_1"=SYS_CONTEXT('USERENV','SESSION_USER');
   return v_iban;
 END;
 /
/*KOMPILIERT UNTER APPBANK*/


/*ADD Policy*/
BEGIN
	DBMS_RLS.ADD_POLICY(
		object_schema 	=>'appbank',
		object_name		=>'BANK_ACCOUNT',
		policy_name		=>'case1simple',
		function_schema	=>'global_bank_ctx',
		policy_function	=>'case_1_simple_policy',
        statement_types =>'SELECT,UPDATE,DELETE'
	);
END;
/
/*kompiliert unter sys*/
CREATE OR REPLACE PACKAGE bank_account_ctx_pkg
  AS
	PROCEDURE set_session_id(session_id_p IN NUMBER); 
	PROCEDURE set_bank_account_ctx(sec_level_attr IN VARCHAR2, 
	  sec_level_val IN VARCHAR2);
  END;
 /
/*kompiliert unter sys*/












CREATE OR REPLACE FUNCTION text_for_id (id_in IN data_by_user.id%TYPE)
    RETURN data_by_user.text%TYPE
IS 
BEGIN
   return priv_text_for_id (
            id_in
          , SYS_CONTEXT ('USERENV', 'CLIENT_IDENTIFIER')
          , SYS_CONTEXT ('USERENV', 'HOST')
          , SYS_CONTEXT ('My_app_context', 'Favorite Flavor')
          );
END text_for_id;
/




select IBAN, OWNER, ACCOUNT_TYPE
into v_iban, v_owner, v_account_type
from BANK_ACCOUNT
where OWNER = SYS_CONTEXT('USERENV', 'SESSION_USER');
return 'IBAN = '|| v_iban;





CASE 2
Befindet sich in einer Tabelle "A" der FK der in der Tabelle "B" auf einen anderen FK verweist und in der Tabelle "C" eindeutig auf den PK der Tabelle "C" hindeutet, so benötigt man in der VPD eine function mit den folgenden Variablen:


CASE 3
Befindet sich in einer Tabelle "A" eine PK der FK in der Tabelle "B" ist und ein PK in einer Tabelle "C" der auch FK in der Tabelle "B" ist, so benötigt man in der VPD eine function mit den folgenden Variablen:














IMG CaseBank.jpeg!

Nun wollen wir uns anhand des Beispiels mit den Bankkunden/Bankkonten eine VPD in PL/SQL Code mal anschauen.

############ begin code listing
/*Case Bank*/

/*Create Tablespace*/
/* 'Datafile' define the path to your db, in this case 'orcl12c' = myDB*/
CREATE SMALLFILE TABLESPACE case_bank
DATAFILE '/u01/app/oracle/oradata/orcl12c/case_bank2.dbf' SIZE 20M
AUTOEXTEND ON NEXT 200K MAXSIZE 2000M;


/*Create new User for our example and use our new Tablespace*/
alter session set "_ORACLE_SCRIPT"=true;
CREATE USER bankapp 
   IDENTIFIED BY pwd4_bankapp
   DEFAULT TABLESPACE case_bank
   QUOTA 20M ON case_bank;

/*Grant privileges to the new user*/
GRANT create session TO bankapp;
GRANT create table TO bankapp;
GRANT create view TO bankapp;
GRANT create any trigger TO bankapp;
GRANT create any procedure TO bankapp;
GRANT create sequence TO bankapp;
GRANT create synonym TO bankapp;

/*login as bankapp user*/
/*Create Tables */
Siehe SQL files;

/*Grant privileges to the tables for bankapp*/
GRANT ALL ON bank_customers to bankapp;
GRANT ALL ON bank_account to bankapp;
GRANT ALL ON transaction to bankapp;

/*login as sysdba on the db*/
sqlplus sys/oracle@localhost/orcl12c as sysdba
oracle

/*Grant privileges to dbms to bankapp */
grant execute on dbms_rls to system with grant option;
GRANT CREATE SESSION, CREATE PROCEDURE, CREATE ANY CONTEXT TO BANKAPP;
GRANT EXECUTE ON DBMS_RLS TO BANKAPP;


/*Create synonym*/
CREATE PUBLIC SYNONYM bank_customer
FOR bankappbank_customer;

CREATE PUBLIC SYNONYM bank_account
FOR bankapp.bank_account;

CREATE PUBLIC SYNONYM transaction
FOR bankapp.transaction;



/*Create security admin for the application context and its package*/
alter session set "_ORACLE_SCRIPT"=true;

CREATE USER secAdm_bank_ctx IDENTIFIED BY pwd4_secAdm;
GRANT CREATE SESSION, CREATE ANY CONTEXT, CREATE PROCEDURE TO secAdm_bank_ctx;
GRANT EXECUTE ON DBMS_SESSION TO secAdm_bank_ctx;

/*Connect as secAdm*/
/*Create global Application Context(GAC)*/
CREATE CONTEXT global_bank_account_ctx USING bank_account_ctx_pkg ACCESSED GLOBALLY;

/*Create a Package für GAC*/
CREATE OR REPLACE PACKAGE bank_account_ctx_pkg
  AS
	PROCEDURE set_session_id(session_id_p IN NUMBER); 
	PROCEDURE set_bank_account_ctx(sec_level_attr IN VARCHAR2, 
	  sec_level_val IN VARCHAR2);
	PROCEDURE clear_hr_session(session_id_p IN NUMBER);
	PROCEDURE clear_hr_context;
  END;
 /

CREATE OR REPLACE PACKAGE BODY bank_account_ctx_pkg
	AS
	session_id_global NUMBER;
	
	PROCEDURE set_session_id(session_id_p IN NUMBER) 
	  AS
	  BEGIN
		session_id_global := session_id_p;
		DBMS_SESSION.SET_IDENTIFIER(session_id_p);
	 END set_session_id;

	 PROCEDURE set_bank_account_ctx(sec_level_attr IN VARCHAR2, sec_level_val IN VARCHAR2)
		AS
		BEGIN
		 DBMS_SESSION.SET_CONTEXT(
			namespace  => 'global_bank_account_ctx',
			attribute  => sec_level_attr,
			value      => sec_level_val,
			username   => USER, -- Retrieves the session user, in this case, bankapp_user
			client_id  => session_id_global);
		END set_bank_account_ctx;

		PROCEDURE clear_hr_session(session_id_p IN NUMBER)
			AS
			BEGIN
			  DBMS_SESSION.SET_IDENTIFIER(session_id_p);
			  DBMS_SESSION.CLEAR_IDENTIFIER;
			END clear_hr_session;

		 PROCEDURE clear_hr_context
		  AS
		  BEGIN
			DBMS_SESSION.CLEAR_CONTEXT('global_bank_account_ctx', session_id_global);
		  END clear_hr_context;
		END;
		/


GRANT EXECUTE ON bank_account_ctx_pkg TO BANKAPP;

/*Create the vpd_function for Bank_Account*/
CREATE OR REPLACE FUNCTION bank_account_sec return varchar2 IS
v_iban number(34);
v_owner varchar2(20);
v_account_type varchar2(20);
BEGIN
select IBAN, OWNER, ACCOUNT_TYPE
into v_iban, v_owner, v_account_type
from BANK_ACCOUNT
where OWNER = SYS_CONTEXT('USERENV', 'SESSION_USER');
return 'IBAN = '|| v_iban;
end;




/*add policy to table*/
BEGIN
	DBMS_RLS.ADD_POLICY(
		object_schema 	=>'bankapp',
		object_name		=>'BANK_ACCOUNT',
		policy_name		=>'account_policy',
		function_schema	=>'secAdm_bank_ctx',
		policy_function	=>'bank_account_sec'	
	);
END;
/

/*Policy dont work with */	
statement_types	=>'SELECT, INSERT, UPDATE, DELETE'


/*Test the GlobalContext*/
EXEC secAdm_bank_ctx.bank_account_ctx_pkg.set_bank_account_ctx('Cust_NO', '1234');
SELECT SYS_CONTEXT('global_bank_account_ctx', 'Cust_NO') Cust_NO FROM DUAL;



/*compile errors*/
show errors


SELECT * FROM BANK_CUSTOMERS;
SELECT COUNT(*) from BANK_CUSTOMERS;

SELECT * FROM BANK_ACCOUNT;
SELECT COUNT(*) from BANK_ACCOUNT;

SELECT * FROM TRANSACTION;
SELECT COUNT(*) from TRANSACTION;



/*Test the SessionID*/
EXEC secAdm_bank_ctx.bank_account_ctx_pkg.set_session_id(34256);
SELECT SYS_CONTEXT('userenv', 'client_identifier') FROM DUAL;
EXEC secAdm_bank_ctx.bank_account_ctx_pkg.set_bank_account_ctx('Benefit Level', 'Highest');
SYS_CONTEXT('global_bank_account_ctx', 'Benefit Level') benefit_level FROM DUAL;














CREATE USER bankapp IDENTIFIED BY pwd4_bankapp
CREATE USER secAdm_bank_ctx IDENTIFIED BY pwd4_secAdm;
	
	



















/*Create a policy Group*/
BEGIN 
	DBMS_RLS.CREATE_POLICY_GROUP
	(
		object_schema	=>'bankapp',
		object_name		=>'BANK_ACCOUNT',
		policy_group	=>'bankapp_group'
	);
END;
/





CREATE OR REPLACE FUNCTION vpd_function_provider_a 
(schema in varchar2, tab in varchar2) return varchar2 as
predicate varchar2(8) default NULL;
BEGIN
	IF LOWER(SYS_CONTEXT('USERENV','CLIENT_IDENTIFIER')) = 'provider_a' 
		THEN predicate := '1=2';
		ELSE NULL;
	END IF;
	RETURN predicate;
END;
/



C






/*Create application context*/
CREATE OR REPLACE CONTEXT bank_accounts_ctx USING bank_accounts_ctx_pkg;

/*Create package to set the context*/
CREATE OR REPLACE PACKAGE bank_accounts_ctx_pkg AS
	PROCEDURE set_ctx;
END;
/

/*Create VPD Policy Function*/
BEGIN dbms_rls.add_policy(
'bankapp',
'BANK_CUSTOMERS',
'customer_policy',
'bankapp',
'customer_security',
'SELECT, INSERT, UPDATE, DELETE'
);
 END;




CREATE OR REPLACE FUNCTION customer_security (schema varchar2, object varchar2) return varchar2 
AS begin
	RETURN 'PositionAccount = SYS_CONTEXT(''userenv'', ''session_user'')';
	END;
/


/*Create package body*/
CREATE OR REPLACE PACKAGE BODY customer_security AS
	FUNCTION account_sec (D1 VARCHAR2, D2 VARCHAR2)
	RETURN VARCHAR2
	IS
		v_predicate VARCHAR2(2000);
	BEGIN
		v_predicate := 'ID_CUSTOMER =
		SYS_CONTEXT(''bank_accounts_ctx'', ''ID_CUSTOMER'')';
		RETURN v_predicate;
	END;
END;
/

/*Create Logon-Trigger*/
CREATE OR REPLACE TRIGGER set_ctx_trig 
AFTER LOGON ON DATABASE
BEGIN
	bank_accounts_ctx_pkg.set_ctx;
END;

/*Create Security Policy and link to the table*/
BEGIN
DBMS_RLS.ADD_Policy(	'bankapp',
						'BANK_CUSTOMERS',
						'customer_policy',
						'sys',
						'customer_security.account_sec',
						'SELECT, INSERT, UPDATE, DELETE'
					);
END;                                   

/


############ end code listing



*****weitere Vorschlag für die Allgemeine Beschreibung der VPD********

Dazu wird zuerst in Oracle PL/SQL eine Function implementiert die diese Einschränkung fachlich vornimmt. Diese Funktion enthält die eigentliche Logik wie die Query mit den Input Parameter erweitert werden soll. Anschließend wird diese Function einer Oracle Policy zugewiesen. Einer Tabelle oder View kann diese Policy oder eine Gruppe von Policys zugewiesen werden. Ab diesem Zeitpunkt werden eintreffende SQL Query auf diese Objekt durch die Policy geschleust und es wird eine erhöhte Spalten/Zeilen Sicherheit erreicht. 


Umsetzung Allgemein

Allgemein gesprochen wird bei jeder SQL Query in der Where Clausel eine weitere Bedingung hinzugefügt die nur Zugriff auf diese Datensätze ermöglicht, welche eindeutig zu der initial übermittelten ID referenziert werden kann.
In anderem DBMS könnte man sowas mit stored Prozedures und/oder Query rewriting umsetzen. Wir beschäftigen uns in diesem Paper aber nur mit der VPD von Oracle.






